package logging

import (
	"fmt"
	"sync"
)

var synchronousLoggerList = make([]LogObserver, 0)
var asynchronousLoggerList = make([]LogObserver, 0)
var loggerListMutex = &sync.Mutex{}

// Debug logs the supplied message. Debug level.
func Debug(context, msg string, args ...interface{}) {
	toLog := fmt.Sprintf("[%s] %s", context, msg)
	log(fmt.Sprintf(toLog, args...), 0)
}

// Log logs the supplied message. Log level.
func Log(msg string, args ...interface{}) {
	log(fmt.Sprintf(msg, args...), 1)
}

// Warning logs the supplied message. Warning level.
func Warning(msg string, args ...interface{}) {
	log(fmt.Sprintf(msg, args...), 2)
}

// Error logs the supplied message. Error report.
func Error(msg string, args ...interface{}) {
	log(fmt.Sprintf(msg, args...), 3)

}

// Custom creates a log message and lets the caller choose the signal number
func Custom(msg string, sig int) {
	log(msg, sig)
}

// RegisterLogObserver adds an observer to record the logs generated by kupak
func RegisterSynchronousLogObserver(observer LogObserver) {
	loggerListMutex.Lock()
	synchronousLoggerList = append(synchronousLoggerList, observer)
	loggerListMutex.Unlock()
}

func RegisterAsynchronousLogObserver(observer LogObserver) {
	loggerListMutex.Lock()
	asynchronousLoggerList = append(asynchronousLoggerList, observer)
	loggerListMutex.Unlock()
}

func log(log string, sig int) {
	loggerListMutex.Lock()
	for _, observer := range synchronousLoggerList {
		observer.Record(log, sig)
	}

	for _, observer := range asynchronousLoggerList {
		go observer.Record(log, sig)
	}
	loggerListMutex.Unlock()
}
